#多线程
##ios中多线程的技术方案

### pthread  
    特点：一套通用的多线程API，适用于Unix\Linix\Windows等系统,跨平台可以移植
    语言：C，
    线程生命周期：程序员管理
### NSThread 
    特点：使用要加面向对象，简单易用，可直接操作线程对象
    语言：OC
    线程生命周期：程序员管理
### GCD
    特点：旨在替代NSThread等线程技术，充分利用设备的多核
    语言：C
    线程生命周期：自动管理
### NSOperation
    特点：基于GCD（底层是GCD），比GCD多了一些更简单实用的功能，使用要加面向对象
    语言：OC
    线程生命周期：自动管理

## pthread
    <!--  
    第一个参数：线程编号的地址
        第二个参数：线程的属性
        第三个参数：线程要执行的函数 void*    (*)     (void *)
        int * 指向int类型的指针  void *指向任何类型的指针，类似于id
        第四个参数：要执行的函数的参数
        函数的返回值 int 0是成功 非0是失败

         __bridge 桥接
         MRC中内存的管理规则： 谁申请 谁释放
         ARC中会自动给OC对象，添加retain， release autoRelease
         把oc中的对象传递给C语言的函数，要桥接
    -->
    - (void)createPtheard {
        pthread_t phread;
        <!--    如果是C语言字符串， char *name = "aaaa"; -->
        <!--    如果传递的是NSString，oc对象，需要通过 __bredige 进行桥接传递给C语言的函数。      -->
        NSString *name = @"bbbb"
        int result = pthread_create(&phread, NULL, demo, (__bridge void *)(name));
        <!--     NSLog(@"touchesBegan %@", [NSThread currentThread]); 主线程-->
        if (result == 0) {
            NSLog(@"成功");
        } else {
            NSLog(@"失败");
        }

    }   
    void *demo(void *param) {
        NSString *name = (__bridge NSString *)(param);
        <!--    子线程      -->
        NSLog(@"Hello %@ %@", [NSThread currentThread], name);
        return NULL;
    }

## NSthread

### NSThread创建
#### 方式1
    NSThread *thread = [[NSThread alloc] initWithTarget: self selector: @selector(demo:) object: @"aa"];
    [thread start];
#### 方式2
    [NSThread detachNewThreadSelector: @selector(demo) toTarget: self withObject: nil];
#### 方式3
    [self performSelectorInBackground: @selector(demo) withObject: nil];

### 线程的状态
![image](https://user-images.githubusercontent.com/45653681/142561176-0a6f942f-6860-4436-87d5-33f06fb220b4.png)
     
    <!-- 使线程处于阻塞状态（不存在与可调度线程池内） -->
    [NSThread sleepForTimeInterval: 3];
    <!--  线程直接退出    -->
    [NSThread exit];
### 线程的状态
