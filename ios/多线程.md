#多线程
## 多线程之间是切换执行的，线程在执行完任务后会制动销毁 

## ios中多线程的技术方案
### pthread  
    特点：一套通用的多线程API，适用于Unix\Linix\Windows等系统,跨平台可以移植
    语言：C，
    线程生命周期：程序员管理
### NSThread 
    特点：使用要加面向对象，简单易用，可直接操作线程对象
    语言：OC
    线程生命周期：程序员管理
### GCD
    特点：旨在替代NSThread等线程技术，充分利用设备的多核
    语言：C
    线程生命周期：自动管理
### NSOperation
    特点：基于GCD（底层是GCD），比GCD多了一些更简单实用的功能，使用要加面向对象
    语言：OC
    线程生命周期：自动管理

## pthread
    <!--  
    第一个参数：线程编号的地址
        第二个参数：线程的属性
        第三个参数：线程要执行的函数 void*    (*)     (void *)
        int * 指向int类型的指针  void *指向任何类型的指针，类似于id
        第四个参数：要执行的函数的参数
        函数的返回值 int 0是成功 非0是失败

         __bridge 桥接
         MRC中内存的管理规则： 谁申请 谁释放
         ARC中会自动给OC对象，添加retain， release autoRelease
         把oc中的对象传递给C语言的函数，要桥接
    -->
    - (void)createPtheard {
        pthread_t phread;
        <!--    如果是C语言字符串， char *name = "aaaa"; -->
        <!--    如果传递的是NSString，oc对象，需要通过 __bredige 进行桥接传递给C语言的函数。      -->
        NSString *name = @"bbbb"
        int result = pthread_create(&phread, NULL, demo, (__bridge void *)(name));
        <!--     NSLog(@"touchesBegan %@", [NSThread currentThread]); 主线程-->
        if (result == 0) {
            NSLog(@"成功");
        } else {
            NSLog(@"失败");
        }

    }   
    void *demo(void *param) {
        NSString *name = (__bridge NSString *)(param);
        <!--    子线程      -->
        NSLog(@"Hello %@ %@", [NSThread currentThread], name);
        return NULL;
    }

## NSthread

### NSThread创建
#### 方式1
    NSThread *thread = [[NSThread alloc] initWithTarget: self selector: @selector(demo:) object: @"aa"];
    [thread start];
#### 方式2
    [NSThread detachNewThreadSelector: @selector(demo) toTarget: self withObject: nil];
#### 方式3
    [self performSelectorInBackground: @selector(demo) withObject: nil];

### 线程的状态
![image](https://user-images.githubusercontent.com/45653681/142561176-0a6f942f-6860-4436-87d5-33f06fb220b4.png)
     
    <!-- 使线程处于阻塞状态（不存在与可调度线程池内） -->
    [NSThread sleepForTimeInterval: 3];
    <!--  线程直接退出    -->
    [NSThread exit];
### 线程的属性
    <!-- 线程的名字 -->
    @property (nullable, copy) NSString *name;
    <!--   线程的优先级，取值0-1. 内核调度算法在决定该运行哪个线程时，会把线程的优先级作为考量因素。较高优先级的线程会比较低优先级的线程
    具有更多的运行机会。而不是先执行完较高优先级再执行较低优先级的任务-->
    @property double threadPriority;

### 互斥锁 @synchronized

    原理： 每一个对象（NSObject）内部都有一个锁（变量），当有线程要进入synchronized到代码块中会先检查对象的锁是打开还是
    关闭状态，默认锁是打开状态（1），如果是线程执行到代码块内部，会先上锁（0）。如果锁被关闭，再有线程要执行代码块就先等待，
    知道锁打开为止
    步骤：
        线程执行到synchronized
        i.检查锁状态，如果是开锁状态（1）转到ii, 如果上锁（0）转到v
        ii.上锁（0）
        iii.执行代码块
        iv.执行完毕 开锁（1）
        v.线程等待(就绪状态)
     加锁后程序执行到效率比不加锁的时候要低，因为要等待线程，但是能保证多个线程同时操作全局变量的安全性
    
    <!--  创建2个线程，同时操作tickets数据     -->
     - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
        NSThread *t = [[NSThread alloc] initWithTarget: self selector: @selector(setTickets) object: nil];
        [t start];
        NSThread *t1 = [[NSThread alloc] initWithTarget: self selector: @selector(setTickets) object: nil];
        [t1 start];
    }
    
    - (void)setTickets {
        while (YES) {
            [NSThread sleepForTimeInterval: 1];
            <!--     加上互斥锁。防止处理数据的混乱         -->
            <!--     NSObject *obj = [NSObject new]; 如果@synchronized (obj)  则每次执行到@synchronized的时候
            会产生一个新的对象，其锁的状态为打开，不能保证线程的同步进行。可以定义一个全局变量传入 @property (nonatomic, strong)                 NSObject *obj; @synchronized (self.obj)-->
            @synchronized (self) {
                if (self.tickets > 0) {
                    self.tickets = self.tickets - 1;
                    NSLog(@"剩余%d", self.tickets);
                } else {
                    NSLog(@"来晚了，票没了");
                    break;
                }
            }
        }
    }
### 原子属性，自旋锁
    属性中修饰符    
    atomic: 原子属性（线程安全），针对多线程设计的，默认值
            保证同一时间只有一个线程能够写入，但是同一个时间多个线程都可以取值
            atomic 本身就有一把锁（自旋锁），单写多读。
    nonatomic:非原子属性
    
    原子属性相当于以下setter  getter方法
    - (void)setName:(NSString *)name {
        @synchronized (self) {
            _name = name;
        }
    }

    - (NSString *)name {
        [self.lock lock];
        _count = tickets;
        [self.lock unlock];
        return _name;
    }
    
    注意：当同时重写setter getter方法时，系统不会默认生成_name属性，所以需要加上 @synthesize name = _name;
    
 ### 互斥锁 和 自旋锁的区别
    互斥锁：如果发现其他线程正在执行锁定代码，线程会进入休眠（就绪状态），等其他线程时间片到打开锁后，线程会被唤醒（执行）
    自旋锁：如果发现其他线程正在执行锁定代码，线程会用死循环的方式，一直等待锁定的代码执行完成，自旋锁更适合执行不耗时的代码    
    注意：所有更新UI的线程都在主线程上
    
### example异步加载网络图片

    <!--   加载图片   -->
    - (void)loadImage {
        NSURL *url = [NSURL URLWithString: @"http://kingglory-api-test.ub-it.com:8080/upload/20200729/1150444090853.jpg"];
        NSData *data = [NSData dataWithContentsOfURL: url];
        UIImage *img = [UIImage imageWithData: data];

        <!--    waitUntilDone 为YES 会等待方法执行完毕，才会执行后续代码 -->
        <!--    在主线程中渲染图片      -->
        [self performSelectorOnMainThread: @selector(updateUI:) withObject: img waitUntilDone: YES];
    }

    - (void)updateUI: (UIImage *)img {
        self.imageView.image = img;
        [self.imageView sizeToFit];
        self.scrollView.contentSize = img.size;
    }
### 自动释放池
自动释放池的创建与销毁
    每一次主线程的消息循环开始的时候会先去创建自动释放池
    消息循环结束前，会释放自动释放池
    自动释放池呗销毁或耗尽时，会向池中所有对象发送release消息，释放所有autoRelease对象
    使用NSThread 做多线程开发时，需要在线程调度方法中手动添加自动释放池

自动释放池和主线程
    在主线程消息循环开始的时候
    在消息循环开始的时候创建了自动释放池，在消息结束的时候倾倒自动释放池
  
什么时候使用自动释放池
    当你写了一个大量数据的循环时，需要在循环体的开始部分添加自动释放池。
    
### 属性修饰符
    strong
    weak
    copy
        字符串
        浅拷贝：没有产生新的对象，而是直接将对象本身的地址返回 return self
        深拷贝：新建对象并赋值，返回这个对象
        （浅拷贝地址一样，深拷贝地址不一样）
    
        copy的对象类型是不可变对象时，为浅拷贝
        copy的对象类型是可变对象时(NSMutable)，为深拷贝
        mutableCopy的对象类型是不可变对象时，为深拷贝
        mutableCopy的对象类型是可变对象时，为深拷贝
        
        @property (nonatomic, copy) NSMutableString *str;
        当为str赋值为不可变容器时，调用NSMutableString的扩展方法时会崩溃
        
        @property (nonatomic, copy) NSString *name;
        <!--  等价于 -->
        - (void)setName:(NSString *)name {
            if (!_name) {
                _name = [name copy];
            }
        }
        @property (nonatomic, strong) NSString *name;
        <!--  等价于 -->
        - (void)setName:(NSString *)name {
            if (!_name) {
                _name = name;
            }
        }
        <!--  如果使用是copy：self.name的时候，只是把str的值赋给了name，copy了一份不可变的字符串。
              如果使用是strong：self.name会指向str的地址 
        -->
        - (void)viewDidLoad {
            NSMutableString *str = [NSMutableString string];
            [str appendString: @"hello"];
            self.name = str;
            [str appendString: @"xx"];
            <!--      此时的self.name 是@"hello"        -->
         }
         
         
         block
         第一种block，全局block  __NSGlobalBlock__
         void (^demo) () = ^{
         };
         NSLog(@"%@", demo);
         第二种block 栈block __NSMallocBlock__
            int number = 5;
            void (^demo)() = ^{
            NSLog(@"%d", number);
            };
            NSLog(@"%@", demo);   
        第三种
         
    assign
